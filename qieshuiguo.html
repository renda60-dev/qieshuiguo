<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AI æ‰‹åŠ¿åˆ‡æ°´æœ</title>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>
    
    <style>
        body {
            margin: 0;
            padding: 0;
            /* 1. èƒŒæ™¯æ”¹ä¸ºçº¯é»‘è‰² */
            background-color: #000000;
            overflow: hidden;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            user-select: none;
        }

        #container {
            position: relative;
            width: 100vw;
            height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
        }

        canvas {
            position: absolute;
            left: 0;
            top: 0;
            z-index: 2;
        }

        .input_video {
            position: absolute;
            top: 0;
            left: 0;
            z-index: -1;
            opacity: 0; 
            width: 1px;
            height: 1px;
        }

        #ui-layer {
            position: absolute;
            z-index: 10;
            width: 100%;
            height: 100%;
            pointer-events: none;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
        }

        .hud-top {
            display: flex;
            justify-content: space-between;
            padding: 20px 40px;
            color: white;
            font-size: 24px;
            font-weight: bold;
            text-shadow: 0 0 10px rgba(255, 255, 255, 0.5);
        }

        .score-box { color: #ffcc00; }
        .timer-box { color: #ff4444; }

        #overlay {
            position: absolute;
            z-index: 20;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.9); /* èƒŒæ™¯æ›´é»‘ */
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            color: white;
            pointer-events: auto;
            transition: opacity 0.3s;
        }

        h1 {
            font-size: 4rem;
            margin: 0 0 20px 0;
            background: linear-gradient(45deg, #ff00cc, #3333ff);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            text-shadow: 0 0 20px rgba(255, 255, 255, 0.2);
        }

        p { font-size: 1.2rem; color: #ccc; max-width: 600px; text-align: center; margin-bottom: 30px;}

        .gesture-hint {
            font-size: 1.5rem;
            color: #00ffcc;
            border: 2px solid #00ffcc;
            padding: 15px 30px;
            border-radius: 50px;
            animation: pulse 2s infinite;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        @keyframes pulse {
            0% { box-shadow: 0 0 0 0 rgba(0, 255, 204, 0.4); }
            70% { box-shadow: 0 0 0 20px rgba(0, 255, 204, 0); }
            100% { box-shadow: 0 0 0 0 rgba(0, 255, 204, 0); }
        }

        #loading-text {
            margin-top: 20px;
            color: #888;
            font-size: 0.9rem;
        }

        .hidden { opacity: 0; pointer-events: none; }
    </style>
</head>
<body>

    <div id="container">
        <video class="input_video" playsinline></video>
        <canvas id="gameCanvas"></canvas>

        <div id="ui-layer">
            <div class="hud-top">
                <div class="score-box">åˆ†æ•°: <span id="score">0</span></div>
                <div class="timer-box">æ—¶é—´: <span id="timer">60</span>s</div>
            </div>
        </div>

        <div id="overlay">
            <h1>AI æ‰‹åŠ¿åˆ‡æ°´æœ</h1>
            <p>å±å¹•é¡¶éƒ¨å°†æœ‰æ°´æœè½ä¸‹ã€‚é£ŸæŒ‡æ§åˆ¶<b>æ°´æœåˆ€</b>ã€‚<br>èƒŒæ™¯çº¯é»‘ï¼Œä¸“æ³¨äºåˆ‡å‰²ã€‚</p>
            
            <!-- 4. å¼€å¯ç•Œé¢æç¤º -->
            <div id="start-area" class="gesture-hint" style="display:none">
                <span>âœŒï¸</span> å¯¹ç€æ‘„åƒå¤´åšå‡ºâ€œå‰ªåˆ€æ‰‹â€å¼€å§‹
            </div>

            <div id="loading-text">æ­£åœ¨åˆå§‹åŒ– AI æ¨¡å‹...</div>
        </div>
    </div>

    <script>
        const config = {
            gameDuration: 60,
            fruitSpawnRate: 800,
            gravity: 0.2, // ç¨å¾®å¢åŠ é‡åŠ›æ„Ÿ
            cursorTrailLength: 8,
            requiredSliceSpeed: 5 
        };

        const state = {
            isPlaying: false,
            score: 0,
            timeLeft: config.gameDuration,
            fruits: [],
            particles: [],
            scorePopups: [], // æ–°å¢ï¼šå­˜å‚¨åˆ†æ•°çš„æµ®åŠ¨åŠ¨ç”»
            handPos: { x: -100, y: -100 },
            prevHandPos: { x: -100, y: -100 },
            trail: [], 
            lastSpawnTime: 0,
            gestureStartCount: 0, // ç”¨äºæ‰‹åŠ¿é˜²æŠ–
            landmarks: null // å­˜å‚¨æ‰‹éƒ¨å…³é”®ç‚¹ç”¨äºæ‰‹åŠ¿è¯†åˆ«
        };

        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const videoElement = document.getElementsByClassName('input_video')[0];
        const overlay = document.getElementById('overlay');
        const startArea = document.getElementById('start-area');
        const scoreEl = document.getElementById('score');
        const timerEl = document.getElementById('timer');
        const loadingText = document.getElementById('loading-text');
        const titleEl = document.querySelector('#overlay h1');
        const pEl = document.querySelector('#overlay p');

        function resize() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
        }
        window.addEventListener('resize', resize);
        resize();

        const FRUIT_TYPES = ['ğŸ', 'ğŸŒ', 'ğŸ‰', 'ğŸ‡', 'ğŸŠ', 'ğŸ', 'ğŸ¥', 'ğŸ¥¥'];
        
        // æ–°å¢ï¼šåˆ†æ•°å¼¹å‡ºç±»
        class ScorePopup {
            constructor(x, y, text) {
                this.x = x;
                this.y = y;
                this.text = text;
                this.life = 1.0;
                this.vy = -3; // å‘ä¸Šé£˜
                this.scale = 1.0;
            }

            update() {
                this.y += this.vy;
                this.life -= 0.02;
                this.scale += 0.01; // ç¨å¾®å˜å¤§
            }

            draw(ctx) {
                ctx.save();
                ctx.translate(this.x, this.y);
                ctx.scale(this.scale, this.scale);
                ctx.globalAlpha = Math.max(0, this.life);
                
                ctx.font = "bold 50px Arial";
                ctx.fillStyle = "#ffcc00";
                ctx.shadowColor = "rgba(255, 204, 0, 0.5)";
                ctx.shadowBlur = 10;
                ctx.textAlign = "center";
                ctx.textBaseline = "middle";
                ctx.fillText(this.text, 0, 0);
                
                // æè¾¹è®©æ–‡å­—æ›´æ¸…æ™°
                ctx.lineWidth = 2;
                ctx.strokeStyle = "white";
                ctx.strokeText(this.text, 0, 0);
                
                ctx.restore();
            }
        }

        class Fruit {
            constructor() {
                this.emoji = FRUIT_TYPES[Math.floor(Math.random() * FRUIT_TYPES.length)];
                this.radius = 65; // æ˜¾è‘—å¢å¤§ç¢°æ’åˆ¤å®šåŠå¾„ (åŸ35)
                
                // 2. æ°´æœä»åº•éƒ¨ç”Ÿæˆ
                this.x = Math.random() * (canvas.width - 100) + 50;
                this.y = canvas.height + 50; 
                
                // 2. ç‰©ç†è®¡ç®—ï¼šæœ€é«˜ç‚¹æ¥è¿‘çª—å£ 85% é«˜åº¦
                // ç›®æ ‡é«˜åº¦ Y (å±å¹•é¡¶ç«¯æ˜¯0ï¼Œæ‰€ä»¥ç›®æ ‡æ˜¯ height * 0.15)
                const targetY = canvas.height * 0.15 + (Math.random() * canvas.height * 0.1); // 15%-25% ä¹‹é—´æµ®åŠ¨
                const h = this.y - targetY; // ä¸Šå‡é«˜åº¦
                
                // v^2 = 2gh => v = sqrt(2gh)
                // å‘ä¸Šé€Ÿåº¦ä¸ºè´Ÿå€¼
                this.vy = -Math.sqrt(2 * config.gravity * h);
                
                // æ°´å¹³é€Ÿåº¦ï¼šå‘å±å¹•ä¸­å¿ƒç¨å¾®èšæ‹¢
                const centerX = canvas.width / 2;
                const distToCenter = centerX - this.x;
                // é£è¡Œæ—¶é—´ t = vy / g
                const timeToApex = Math.abs(this.vy) / config.gravity;
                // ç®€å•çš„æ°´å¹³ä½ç§»é€»è¾‘ï¼Œè®©å®ƒåœ¨åˆ°è¾¾æœ€é«˜ç‚¹é™„è¿‘æ—¶ç¨å¾®é è¿‘ä¸­å¿ƒæˆ–ç©¿è¿‡ä¸­å¿ƒ
                this.vx = (distToCenter / timeToApex) * (0.5 + Math.random() * 0.5); // éšæœºç³»æ•°

                this.rotation = 0;
                this.rotationSpeed = (Math.random() - 0.5) * 0.15;
                this.active = true;
            }

            update() {
                this.x += this.vx;
                this.y += this.vy;
                this.vy += config.gravity;
                this.rotation += this.rotationSpeed;

                // è¾¹ç•Œæ£€æŸ¥
                if (this.y > canvas.height + 100) {
                    this.active = false;
                }
            }

            draw(ctx) {
                ctx.save();
                ctx.translate(this.x, this.y);
                ctx.rotate(this.rotation);
                ctx.font = "120px Arial"; // æ˜¾è‘—å¢å¤§æ°´æœæ˜¾ç¤ºå¤§å° (åŸ60px)
                ctx.textAlign = "center";
                ctx.textBaseline = "middle";
                ctx.fillText(this.emoji, 0, 10); // å¾®è°ƒå‚ç›´å¯¹é½
                ctx.restore();
            }
        }

        class Particle {
            constructor(x, y, color) {
                this.x = x;
                this.y = y;
                this.vx = (Math.random() - 0.5) * 15;
                this.vy = (Math.random() - 0.5) * 15;
                this.life = 1.0;
                this.color = color;
                this.size = Math.random() * 5 + 2;
            }

            update() {
                this.x += this.vx;
                this.y += this.vy;
                this.vy += config.gravity;
                this.life -= 0.03;
            }

            draw(ctx) {
                ctx.globalAlpha = Math.max(0, this.life);
                ctx.fillStyle = this.color;
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
                ctx.fill();
                ctx.globalAlpha = 1.0;
            }
        }

        function renderLoop() {
            // 1. æ¸…ç©ºç”»å¸ƒ (èƒŒæ™¯å·²ç»æ˜¯çº¯é»‘ CSS)
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            // æ³¨æ„ï¼šè¿™é‡Œä¸å†ç»˜åˆ¶ videoElementï¼Œå®ç°â€œèƒŒæ™¯çº¯é»‘è‰²â€çš„éœ€æ±‚
            
            // æ£€æµ‹æ‰‹åŠ¿å¯åŠ¨ (ä»…åœ¨éæ¸¸æˆçŠ¶æ€)
            if (!state.isPlaying && state.landmarks) {
                detectStartGesture(state.landmarks);
            }

            // æ¸¸æˆé€»è¾‘
            if (state.isPlaying) {
                updateGameLogic();
            } else {
                // éæ¸¸æˆçŠ¶æ€ä¹Ÿç”»å…‰æ ‡ï¼Œæ–¹ä¾¿ç”¨æˆ·çŸ¥é“æ‰‹åœ¨å“ª
                drawCursor();
            }

            requestAnimationFrame(renderLoop);
        }

        // 4. æ‰‹åŠ¿æ£€æµ‹é€»è¾‘ï¼šå‰ªåˆ€æ‰‹ (Index & Middle Extended, others curled)
        function detectStartGesture(landmarks) {
            // ç®€å•çš„åˆ¤æ–­ï¼šé£ŸæŒ‡æŒ‡å°–(8)é«˜äºå…³èŠ‚(6)ï¼Œä¸­æŒ‡æŒ‡å°–(12)é«˜äºå…³èŠ‚(10)
            // ä¸” æ— åæŒ‡(16)ä½äºå…³èŠ‚(14)ï¼Œå°æŒ‡(20)ä½äºå…³èŠ‚(18)
            // æ³¨æ„ï¼šYè½´å‘ä¸‹ä¸ºæ­£ï¼Œæ‰€ä»¥"é«˜"æ„å‘³ç€ y å€¼æ›´å°
            
            const indexUp = landmarks[8].y < landmarks[6].y;
            const middleUp = landmarks[12].y < landmarks[10].y;
            const ringDown = landmarks[16].y > landmarks[14].y;
            const pinkyDown = landmarks[20].y > landmarks[18].y;

            if (indexUp && middleUp && ringDown && pinkyDown) {
                state.gestureStartCount++;
                // å¢åŠ è§†è§‰åé¦ˆ
                startArea.style.background = `rgba(0, 255, 204, ${Math.min(1, state.gestureStartCount / 20)})`;
                startArea.style.color = '#000';
                
                if (state.gestureStartCount > 20) { // ä¿æŒçº¦ 0.5 ç§’
                    startGame();
                    state.gestureStartCount = 0;
                }
            } else {
                state.gestureStartCount = 0;
                startArea.style.background = 'transparent';
                startArea.style.color = '#00ffcc';
            }
        }

        function updateGameLogic() {
            // æ›´æ–°è½¨è¿¹
            state.trail.push({ x: state.handPos.x, y: state.handPos.y });
            if (state.trail.length > config.cursorTrailLength) state.trail.shift();

            const now = Date.now();
            if (now - state.lastSpawnTime > config.fruitSpawnRate) {
                state.fruits.push(new Fruit());
                state.lastSpawnTime = now;
                if (config.fruitSpawnRate > 300) config.fruitSpawnRate -= 2;
            }

            for (let i = state.fruits.length - 1; i >= 0; i--) {
                const f = state.fruits[i];
                f.update();

                const dx = state.handPos.x - state.prevHandPos.x;
                const dy = state.handPos.y - state.prevHandPos.y;
                const handSpeed = Math.hypot(dx, dy);
                const dist = Math.hypot(f.x - state.handPos.x, f.y - state.handPos.y);

                if (f.active && dist < f.radius + 40 && handSpeed > config.requiredSliceSpeed) {
                    f.active = false;
                    const points = 10;
                    state.score += points;
                    scoreEl.innerText = state.score;
                    
                    // è§¦å‘ç‰¹æ•ˆ
                    createExplosion(f.x, f.y);
                    // æ–°å¢ï¼šæ·»åŠ æµ®åŠ¨åˆ†æ•°
                    state.scorePopups.push(new ScorePopup(f.x, f.y, "+" + points));
                    
                    state.fruits.splice(i, 1);
                } else if (!f.active) {
                    state.fruits.splice(i, 1);
                }
            }

            // æ›´æ–°ç²’å­
            for (let i = state.particles.length - 1; i >= 0; i--) {
                const p = state.particles[i];
                p.update();
                if (p.life <= 0) state.particles.splice(i, 1);
            }
            
            // æ–°å¢ï¼šæ›´æ–°æµ®åŠ¨åˆ†æ•°
            for (let i = state.scorePopups.length - 1; i >= 0; i--) {
                const popup = state.scorePopups[i];
                popup.update();
                if (popup.life <= 0) state.scorePopups.splice(i, 1);
            }

            drawGameElements();
        }

        function drawGameElements() {
            state.fruits.forEach(f => f.draw(ctx));
            state.particles.forEach(p => p.draw(ctx));
            // æ–°å¢ï¼šç»˜åˆ¶æµ®åŠ¨åˆ†æ•°
            state.scorePopups.forEach(popup => popup.draw(ctx));

            if (state.trail.length > 1) {
                ctx.beginPath();
                ctx.moveTo(state.trail[0].x, state.trail[0].y);
                for (let i = 1; i < state.trail.length; i++) {
                    const p0 = state.trail[i-1];
                    const p1 = state.trail[i];
                    ctx.quadraticCurveTo(p0.x, p0.y, (p0.x + p1.x)/2, (p0.y + p1.y)/2);
                }
                ctx.lineCap = 'round';
                ctx.lineJoin = 'round';
                ctx.lineWidth = 6;
                ctx.strokeStyle = '#ffffff';
                ctx.shadowBlur = 15;
                ctx.shadowColor = '#00ffcc';
                ctx.stroke();
                ctx.shadowBlur = 0;
            }
            
            // ç»˜åˆ¶åˆ€
            drawCursor();
        }

        function drawCursor() {
            // 3. è®¾ç½®è™šæ‹Ÿå…‰æ ‡ä¸ºå¯çˆ±æ°´æœåˆ€
            const { x, y } = state.handPos;
            const { x: px, y: py } = state.prevHandPos;
            
            // è®¡ç®—ç§»åŠ¨è§’åº¦ï¼Œè®©åˆ€å¤´æŒ‡å‘ç§»åŠ¨æ–¹å‘
            let angle = Math.atan2(y - py, x - px);
            // å¦‚æœç§»åŠ¨å¾ˆæ…¢ï¼Œä¿æŒé»˜è®¤è§’åº¦ (-45åº¦ï¼Œæœå·¦ä¸Š)
            if (Math.abs(x - px) < 1 && Math.abs(y - py) < 1) {
                angle = -Math.PI / 4; 
            } else {
                // åˆ€å°–é€šå¸¸ä¸Emojiæ–¹å‘æœ‰å…³ï¼Œ'ğŸ”ª' é»˜è®¤æœå·¦ä¸‹ã€‚
                // æˆ‘ä»¬åŠ ä¸ªåç§»é‡è®©å®ƒçœ‹èµ·æ¥é¡ºæ‰‹
                angle += Math.PI * 0.75;
            }

            ctx.save();
            ctx.translate(x, y);
            ctx.rotate(angle);
            ctx.font = "80px Arial"; // ç¨å¾®åŠ å¤§åˆ€çš„å¤§å° (åŸ40px)
            ctx.textAlign = "center";
            ctx.textBaseline = "middle";
            ctx.fillText("ğŸ”ª", 0, 0);
            ctx.restore();
        }

        function createExplosion(x, y) {
            for (let i = 0; i < 15; i++) {
                const colors = ['#FFF', '#ffeb3b', '#ff5722'];
                state.particles.push(new Particle(x, y, colors[Math.floor(Math.random()*colors.length)]));
            }
        }

        const hands = new Hands({locateFile: (file) => {
            return `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`;
        }});

        hands.setOptions({
            maxNumHands: 1,
            modelComplexity: 1,
            minDetectionConfidence: 0.5,
            minTrackingConfidence: 0.5
        });

        hands.onResults((results) => {
            if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
                const landmarks = results.multiHandLandmarks[0];
                state.landmarks = landmarks; // ä¿å­˜ç”¨äºæ‰‹åŠ¿è¯†åˆ«

                const indexTip = landmarks[8];
                const x = (1 - indexTip.x) * canvas.width;
                const y = indexTip.y * canvas.height;

                state.prevHandPos = { ...state.handPos };
                state.handPos = { x, y };
            } else {
                state.landmarks = null;
            }
        });

        const camera = new Camera(videoElement, {
            onFrame: async () => {
                await hands.send({image: videoElement});
            },
            width: 640,
            height: 480
        });

        function startGame() {
            if (state.isPlaying) return;
            state.isPlaying = true;
            state.score = 0;
            state.timeLeft = config.gameDuration;
            state.fruits = [];
            state.particles = [];
            state.scorePopups = []; // é‡ç½®åˆ†æ•°å¼¹çª—
            state.lastSpawnTime = Date.now();
            config.fruitSpawnRate = 800;
            
            scoreEl.innerText = "0";
            timerEl.innerText = state.timeLeft;
            overlay.classList.add('hidden');
            
            const timerInterval = setInterval(() => {
                state.timeLeft--;
                timerEl.innerText = state.timeLeft;
                if (state.timeLeft <= 0) {
                    clearInterval(timerInterval);
                    endGame();
                }
            }, 1000);
        }

        function endGame() {
            state.isPlaying = false;
            overlay.classList.remove('hidden');
            titleEl.innerText = "æ—¶é—´åˆ°!";
            pEl.innerHTML = `æœ€ç»ˆå¾—åˆ†: <span style="color:#ffcc00; font-size:1.5em">${state.score}</span>`;
            startArea.style.background = 'transparent'; // é‡ç½®æ‰‹åŠ¿æŒ‰é’®æ ·å¼
        }

        camera.start()
            .then(() => {
                console.log("Camera init success");
                loadingText.style.display = 'none';
                startArea.style.display = 'flex'; // æ˜¾ç¤ºæ‰‹åŠ¿æç¤º
                requestAnimationFrame(renderLoop);
            })
            .catch(err => {
                loadingText.innerText = "æ— æ³•è®¿é—®æ‘„åƒå¤´ï¼Œè¯·æ£€æŸ¥æƒé™ã€‚";
                loadingText.style.color = "red";
            });

    </script>
</body>
</html>